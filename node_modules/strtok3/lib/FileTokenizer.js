"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractTokenizer_1 = require("./AbstractTokenizer");
var fs = require("fs-extra");
var _1 = require("./");
var bluebird_1 = require("bluebird");
var FileTokenizer = /** @class */ (function (_super) {
    __extends(FileTokenizer, _super);
    function FileTokenizer(fd, fileSize) {
        var _this = _super.call(this) || this;
        _this.fd = fd;
        _this.fileSize = fileSize;
        return _this;
    }
    /**
     * Read buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an integer specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @returns Promise number of bytes read
     */
    FileTokenizer.prototype.readBuffer = function (buffer, offset, length, position) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length; }
        if (position) {
            this.position = position;
        }
        if (length === 0) {
            return bluebird_1.Promise.resolve(0);
        }
        if (!length) {
            length = buffer.length;
        }
        return fs.read(this.fd, buffer, offset, length, this.position).then(function (res) {
            if (res.bytesRead < length)
                throw new Error(_1.endOfFile);
            _this.position += res.bytesRead;
            return res.bytesRead;
        });
    };
    /**
     * Peek buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an int
     * eger specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @returns Promise number of bytes read
     */
    FileTokenizer.prototype.peekBuffer = function (buffer, offset, length, position) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length; }
        if (position === void 0) { position = this.position; }
        return fs.read(this.fd, buffer, offset, length, position).then(function (res) {
            return res.bytesRead;
        });
    };
    /**
     * @param length Number of bytes to ignore
     */
    FileTokenizer.prototype.ignore = function (length) {
        var bytesLeft = this.fileSize - this.position;
        if (length <= bytesLeft) {
            this.position += length;
            return bluebird_1.Promise.resolve(length);
        }
        else {
            this.position += bytesLeft;
            return bluebird_1.Promise.resolve(bytesLeft);
        }
    };
    FileTokenizer.prototype.close = function () {
        return fs.close(this.fd);
    };
    return FileTokenizer;
}(AbstractTokenizer_1.AbstractTokenizer));
exports.FileTokenizer = FileTokenizer;
