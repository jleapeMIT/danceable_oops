"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReadStreamTokenizer_1 = require("./ReadStreamTokenizer");
var FileTokenizer_1 = require("./FileTokenizer");
var fs = require("fs-extra");
var bluebird_1 = require("bluebird");
/**
 * Used to reject read if end-of-Stream or end-of-file is reached
 * @type {Error}
 */
exports.endOfFile = "End-Of-File";
var IgnoreType = /** @class */ (function () {
    /**
     * @param len Number of bytes to ignore (skip)
     */
    function IgnoreType(len) {
        this.len = len;
    }
    // ToDo: don't read,, but skip data
    IgnoreType.prototype.get = function (buf, off) {
        return buf.slice(off, off + this.len);
    };
    return IgnoreType;
}());
exports.IgnoreType = IgnoreType;
/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param stream Stream.Readable
 * @returns {Promise<ReadStreamTokenizer>}
 */
function fromStream(stream) {
    if (stream.path) {
        return fs.stat(stream.path).then(function (stat) {
            return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, stat.size);
        });
    }
    return bluebird_1.Promise.resolve(new ReadStreamTokenizer_1.ReadStreamTokenizer(stream));
}
exports.fromStream = fromStream;
/**
 * Construct ReadStreamTokenizer from given file path.
 * @param filePath
 * @returns {Promise<FileTokenizer>}
 */
function fromFile(filePath) {
    return fs.pathExists(filePath).then(function (exist) {
        if (!exist) {
            throw new Error("File not found: " + filePath);
        }
        return fs.stat(filePath).then(function (stat) {
            return fs.open(filePath, "r").then(function (fd) {
                return new FileTokenizer_1.FileTokenizer(fd, stat.size);
            });
        });
    });
}
exports.fromFile = fromFile;
