"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var AsfParser_1 = require("./asf/AsfParser");
var FlacParser_1 = require("./flac/FlacParser");
var MP4Parser_1 = require("./mp4/MP4Parser");
var OggParser_1 = require("./ogg/OggParser");
var strtok3 = require("strtok3");
var path = require("path");
var AiffParser_1 = require("./aiff/AiffParser");
var RiffParser_1 = require("./riff/RiffParser");
var WavPackParser_1 = require("./wavpack/WavPackParser");
var MpegParser_1 = require("./mpeg/MpegParser");
var ParserFactory = /** @class */ (function () {
    function ParserFactory() {
        // ToDo: expose warnings to API
        this.warning = [];
    }
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromFile(filePath).then(function (fileTokenizer) {
            var parser = ParserFactory.getParserForExtension(filePath);
            if (parser) {
                return parser.parse(fileTokenizer, opts).then(function (metadata) {
                    return fileTokenizer.close().then(function () {
                        return metadata;
                    });
                }).catch(function (err) {
                    return fileTokenizer.close().then(function () {
                        throw err;
                    });
                });
            }
            else {
                throw new Error('No parser found for extension: ' + path.extname(filePath));
            }
        });
    };
    /**
     * Parse metadata from stream
     * @param stream Node stream
     * @param mimeType The mime-type, e.g. "audio/mpeg", extension e.g. ".mp3" or filename. This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseStream = function (stream, mimeType, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromStream(stream).then(function (tokenizer) {
            if (!tokenizer.fileSize && opts.fileSize) {
                tokenizer.fileSize = opts.fileSize;
            }
            // Interpret mimeType as extension
            var parser = ParserFactory.getParserForMimeType(mimeType) || ParserFactory.getParserForExtension(mimeType);
            if (parser === null) {
                // No MIME-type mapping found
                throw new Error("MIME-type or extension not supported:" + mimeType);
            }
            // Parser found, execute parser
            return parser.parse(tokenizer, opts);
        });
    };
    /**
     * @param filePath Path, filename or extension to audio file
     * @return ITokenParser if extension is supported; otherwise false
     */
    ParserFactory.getParserForExtension = function (filePath) {
        var extension = path.extname(filePath).toLocaleLowerCase() || filePath;
        switch (extension) {
            case ".mp2":
            case ".mp3":
            case ".m2a":
                return new MpegParser_1.MpegParser();
            case ".ape":
                return new APEv2Parser_1.APEv2Parser();
            case ".aac":
            case ".mp4":
            case ".m4a":
            case ".m4b":
            case ".m4pa":
            case ".m4v":
            case ".m4r":
            case ".3gp":
                return new MP4Parser_1.MP4Parser();
            case ".wma":
            case ".wmv":
            case ".asf":
                return new AsfParser_1.AsfParser();
            case ".flac":
                return new FlacParser_1.FlacParser();
            case ".ogg":
            case ".ogv":
            case ".oga":
            case ".ogx":
            case ".opus": // recommended filename extension for Ogg Opus files
                return new OggParser_1.OggParser();
            case ".aif":
            case ".aiff":
            case ".aifc":
                return new AiffParser_1.AIFFParser();
            case ".wav":
                return new RiffParser_1.WavePcmParser();
            case ".wv":
            case ".wvp":
                return new WavPackParser_1.WavPackParser();
            default:
                return false;
        }
    };
    /**
     * @param {string} mimeType MIME-Type, extension, path or filename
     * @returns ITokenParser if MIME-type is supported; otherwise false
     */
    ParserFactory.getParserForMimeType = function (mimeType) {
        switch (mimeType) {
            case "audio/mpeg":
                return new MpegParser_1.MpegParser(); // ToDo: handle ID1 header as well
            case "audio/x-monkeys-audio":
                return new APEv2Parser_1.APEv2Parser();
            case "audio/aac":
            case "audio/aacp":
            case "audio/mp4":
            case "audio/x-aac":
            case "audio/x-m4a":
                return new MP4Parser_1.MP4Parser();
            case "video/x-ms-asf":
            case "audio/x-ms-wma":
                return new AsfParser_1.AsfParser();
            case "audio/flac":
            case "audio/x-flac":
                return new FlacParser_1.FlacParser();
            case "audio/ogg": // RFC 7845
            case "application/ogg":
            case "video/ogg":
                return new OggParser_1.OggParser();
            case "audio/aiff":
            case "audio/x-aif":
            case "audio/x-aifc":
                return new AiffParser_1.AIFFParser();
            case "audio/wav":
            case "audio/wave":
                return new RiffParser_1.WavePcmParser();
            case "audio/x-wavpack":
                return new WavPackParser_1.WavPackParser();
            default:
                return false;
        }
    };
    return ParserFactory;
}());
exports.ParserFactory = ParserFactory;
